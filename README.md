# Celestia ZK DA challenge

This repository contains a [RISC Zero] guest program that demonstrates ZK data availability challenges with [Celestia]
and [Blobstream]. Users can use this program to generate a proof that a specific blob inside an Eclipse index blob
(any of the blobs inside the index or the index itself) is unavailable on Celestia.

The guest program uses Blobstream to attest the authenticity of Celestia blocks, Celestia row proofs to derive
the size of each Celestia block's Extended Data Square (EDS) and then performs a range check of the share indices
of the challenged blob. If the challenged blob is out of bounds, the blob is proven as unavailable.

## How to run

The `publisher` package is used to run the guest program and attempts to publish a proof to a deployed [Counter] contract.
The [Counter] is an example contract that implements a counter if the supplied ZK proof is valid. I'll add instructions
on how to deploy the counter a little later, in the meantime use a fixed address like in the example. The guest will
execute normally, what will fail is the publishing of the proof to Ethereum.

You will also need:
* An Ethereum private key, used to publish the proof to the [Counter] contract
* A Sepolia RPC URL to fetch Blobstream data then publish the proof
* A Celestia Mocha RPC URL, to fetch data about the index blob.

```shell
# A previously deployed counter. This will not work because of the guest image ID check.
export COUNTER_ADDRESS=0x5CcC5C91357e68c644448f05e0027cC753c37711

RUST_LOG=info RISC0_DEV_MODE=1 cargo run --package cli --bin publisher -- \
    --eth-wallet-private-key ${ETH_PRIVATE_KEY} \
    --eth-rpc-url ${SEPOLIA_RPC_URL} \
    --celestia-rpc-url ${MOCHA_RPC_URL} \
    --counter-address ${COUNTER_ADDRESS} \
    --index-blob 6671289:6:4 \
    --challenged-blob 6671289:6:4
```

You can test a few use cases:

1. Valid DA challenge: Specify a blob with an out-of-bounds start index (ex: 6671289:1000000:1024) and challenge the same blob.
2. Invalid index challenge: Specify a valid index blob (ex: 6671289:6:4) and challenge the same blob.
3. Invalid blob challenge inside the index: Specify a valid index blob (ex: 6671289:6:4) and challenge a random blob inside it (ex: 6671289:1000:1000)
4. Deserialization error: Specify an existing blob that does not deserialize nicely (ex: 6671289:6:4).

## Integration tests

The integration tests use a Docker Compose setup with the following components:
* A local [Celestia] deployment
* [Anvil] to emulate Ethereum
* A [Blobstream] service to publish Celestia block ranges to Anvil.

This is all managed by the `ci/docker-compose.yml` file.

The integration tests can be run with the following command:

```shell
bash scripts/run-tests.sh
```

If you want to reset the test environment, run `bash scripts/reset-tests.sh --reset`.
Currently, tests must be run sequentially because the Ethereum RPC calls are not thread safe.




# Docs generated by the RISC Zero template (will be merged/removed)
This example implements a counter that increments based on off-chain RISC Zero [Steel] proofs submitted to the [Counter] contract.
The contract interacts with ERC-20 tokens, using [Steel] proofs to verify that an account holds at least 1 token before incrementing the counter.

## Overview

The [Counter] contract is designed to interact with the Ethereum blockchain, leveraging the power of RISC Zero [Steel] proofs to perform a specific operation: incrementing a counter based on the token holdings of an account.

### Contract Functionality

#### Increment Counter

The core functionality of the [Counter] contract is to increment an internal counter whenever a valid proof was submitted.
This proof must demonstrate that a specified account holds at least one unit of a particular ERC-20 token.
The contract ensures that the counter is only incremented when the proof is verified and the condition of holding at least one token is met.

#### Steel Proof Submission

Users or entities can submit proofs to the [Counter] contract.
These proofs are generated off-chain using the RISC Zero zkVM.
The proof encapsulates the verification of an account's token balance without exposing the account's details or requiring direct on-chain queries.

#### Token Balance Verification

Upon receiving a [Steel] proof, the [Counter] contract decodes the proof and validates it against the contract's state at a certain block height.
This ensures that the account in question actually holds at least one token at the time the proof was generated.

#### Counter Management

The contract maintains an internal counter, which is publicly viewable.
This counter represents the number of successful verifications that have occurred.
The contract includes functionality to query the current value of the counter at any time.

## Dependencies

To get started, you need to have the following installed:

- [Rust]
- [Foundry]
- [RISC Zero]

### Configuring Bonsai

***Note:*** *To request an API key [complete the form here](https://bonsai.xyz/apply).*

With the Bonsai proving service, you can produce a [Groth16 SNARK proof] that is verifiable on-chain.
You can get started by setting the following environment variables with your API key and associated URL.

```bash
export BONSAI_API_KEY="YOUR_API_KEY" # see form linked above
export BONSAI_API_URL="BONSAI_URL" # provided with your api key
```

## Deploy Your Application

When you're ready, follow the [deployment guide] to get your application running on [Sepolia] or a local network.

[Foundry]: https://getfoundry.sh/
[Groth16 SNARK proof]: https://www.risczero.com/news/on-chain-verification
[RISC Zero]: https://dev.risczero.com/api/zkvm/install
[Sepolia]: https://www.alchemy.com/overviews/sepolia-testnet
[deployment guide]: ./deployment-guide.md
[Rust]: https://doc.rust-lang.org/cargo/getting-started/installation.html
[Counter]: ./contracts/src/Counter.sol
[Steel]: https://www.risczero.com/blog/introducing-steel
